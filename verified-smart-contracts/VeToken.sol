{{
  "language": "Solidity",
  "sources": {
    "VeToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IERC20.sol\";\n\nimport \"SafeOwnable.sol\";\nimport \"Math.sol\";\nimport \"ReentrancyGuard.sol\";\n\n// veWILD is a non-transferrable governance token minted by locking up WILD\n// The longer the lock period, the higher the reward\n// 1 veWILD = WILD locked for 4 years\n\ncontract VeToken is SafeOwnable, ReentrancyGuard {\n\n  uint private constant MIN_LOCK_PERIOD = 1 weeks;\n  uint private constant MAX_LOCK_PERIOD = 1460 days; // 4 years\n  uint private constant WITHDRAW_DELAY  = 1 days;\n\n  mapping (address => uint) public balanceOf; // veBalanceOf\n  mapping (address => uint) public lockedBalanceOf;\n  mapping (address => uint) public lockedUntil;\n  mapping (address => uint) public rewardSnapshot;\n  mapping (address => uint) public withdrawAt;\n\n  string public constant name     = 'veWILD';\n  string public constant symbol   = 'veWILD';\n  uint8  public constant decimals = 18;\n  uint   public totalSupply;\n  uint   public totalLocked;\n  uint   public distributionPeriod;\n\n  address public  lockedToken;     // WILD\n  uint    public  lastAccrueBlock;\n  uint    public  lastIncomeBlock;\n  uint    public  rewardPerToken;  // Reward per veToken. Increases over time.\n  uint    private rewardRateStored;\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  event Lock            (address indexed account, uint lockedBalance, uint veBalance, uint lockedUntil);\n  event WithdrawRequest (address indexed account, uint amount, uint withdrawAt);\n  event Withdraw        (address indexed account, uint amount);\n  event Claim           (address indexed account, uint veBalance, uint claimAmount);\n  event NewIncome       (uint addAmount, uint remainingAmount, uint rewardRate);\n  event NewDistributionPeriod(uint value);\n\n  function initialize(address _lockedToken, uint _distributionPeriod) external {\n    require(lockedToken == address(0), \"VeToken: already initialized\");\n\n    lockedToken     = _lockedToken;\n    lastAccrueBlock = block.number;\n    _setDistributionPeriod(_distributionPeriod);\n\n    owner = msg.sender;\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\n  }\n\n  function lock(uint _amount, uint _newLockedUntil) external nonReentrant {\n    uint lockSeconds = _newLockedUntil - block.timestamp;\n\n    require(lockSeconds >= MIN_LOCK_PERIOD, \"VeToken: lock time too short\");\n    require(lockSeconds <= MAX_LOCK_PERIOD, \"VeToken: lock time too long\");\n    require(_newLockedUntil >= lockedUntil[msg.sender], \"VeToken: cannot reduce locked time\");\n\n    _claim();\n\n    if (_amount > 0) {\n      lockedBalanceOf[msg.sender] += _amount;\n      totalLocked += _amount;\n      IERC20(lockedToken).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    _updateLock(msg.sender, _newLockedUntil);\n    _checkReserves();\n\n    // TODO: 1M total locked WILD limit. remove after the initial test period\n    require(totalLocked < 1000000e18, \"lock limit reached\");\n\n    emit Lock(msg.sender, lockedBalanceOf[msg.sender], balanceOf[msg.sender], _newLockedUntil);\n  }\n\n  function requestWithdraw() external nonReentrant {\n    uint withdrawAmount = lockedBalanceOf[msg.sender];\n\n    require(withdrawAmount > 0, \"VeToken: nothing to withdraw\");\n    require(block.timestamp > lockedUntil[msg.sender], \"VeToken: cannot withdraw before unlock\");\n\n    _claim();\n    withdrawAt[msg.sender] = block.timestamp + WITHDRAW_DELAY;\n\n    emit WithdrawRequest(msg.sender, withdrawAmount, withdrawAt[msg.sender]);\n  }\n\n  function withdraw() external nonReentrant {\n    uint withdrawTime = withdrawAt[msg.sender];\n    uint withdrawAmount = lockedBalanceOf[msg.sender];\n\n    require(withdrawTime > 0 && withdrawTime <= block.timestamp, \"VeToken: withdraw delay not over\");\n\n    withdrawAt[msg.sender] = 0;\n\n    totalLocked -= withdrawAmount;\n    lockedBalanceOf[msg.sender] = 0;\n    _setBalance(msg.sender, 0);\n\n    IERC20(lockedToken).transfer(msg.sender, withdrawAmount);\n    _checkReserves();\n\n    emit Withdraw(msg.sender, withdrawAmount);\n  }\n\n  // Claiming resets veWILD balance based on locked WILD and lock time remaining.\n  function claim() external nonReentrant {\n    _claim();\n    _checkReserves();\n  }\n\n  // Update rewardRateStored to distribute previous unvested income + new income\n  // over the next distributionPeriod blocks\n  function addIncome(uint _addAmount) external nonReentrant {\n    _accrue();\n    IERC20(lockedToken).transferFrom(msg.sender, address(this), _addAmount);\n\n    uint unvestedIncome = _updateRewardRate(_addAmount, distributionPeriod);\n    _checkReserves();\n\n    emit NewIncome(_addAmount, unvestedIncome, rewardRateStored);\n  }\n\n  function setDistributionPeriod(uint _blocks) external onlyOwner {\n    _setDistributionPeriod(_blocks);\n  }\n\n  // If no new income is added for more than distributionPeriod blocks,\n  // then do not distribute any more rewards\n  function rewardRate() public view returns(uint) {\n    uint blocksElapsed = block.number - lastIncomeBlock;\n\n    if (blocksElapsed < distributionPeriod) {\n      return rewardRateStored;\n    } else {\n      return 0;\n    }\n  }\n\n  function pendingAccountReward(address _account) public view returns(uint) {\n    uint pedingRewardPerToken = rewardPerToken + _pendingRewardPerToken();\n    uint rewardPerTokenDelta  = pedingRewardPerToken - rewardSnapshot[_account];\n    return rewardPerTokenDelta * balanceOf[_account] / 1e18;\n  }\n\n  function _claim() internal {\n    _accrue();\n    uint pendingReward = pendingAccountReward(msg.sender);\n\n    if(pendingReward > 0) {\n      IERC20(lockedToken).transfer(msg.sender, pendingReward);\n    }\n\n    rewardSnapshot[msg.sender] = rewardPerToken;\n    _updateLock(msg.sender, lockedUntil[msg.sender]);\n\n    emit Claim(msg.sender, balanceOf[msg.sender], pendingReward);\n  }\n\n  function _accrue() internal {\n    rewardPerToken += _pendingRewardPerToken();\n    lastAccrueBlock = block.number;\n  }\n\n  function _setDistributionPeriod(uint _blocks) internal {\n    require(_blocks > 0, \"VeToken: distribution period must be >= 100 blocks\");\n    _accrue();\n    _updateRewardRate(0, _blocks);\n    emit NewDistributionPeriod(_blocks);\n  }\n\n  function _updateRewardRate(uint _addAmount, uint _newDistributionPeriod) internal returns(uint) {\n    // Avoid inflation of blocksElapsed inside of _pendingRewardPerToken()\n    // Ensures _pendingRewardPerToken() is 0 and all rewards are accounted for\n    require(block.number == lastAccrueBlock, \"VeToken: accrue first\");\n\n    uint blocksElapsed  = Math.min(distributionPeriod, block.number - lastIncomeBlock);\n    uint unvestedIncome = rewardRateStored * (distributionPeriod - blocksElapsed);\n\n    rewardRateStored   = (unvestedIncome + _addAmount) / _newDistributionPeriod;\n    distributionPeriod = _newDistributionPeriod;\n    lastIncomeBlock    = block.number;\n\n    return unvestedIncome;\n  }\n\n  function _updateLock(address _account, uint _newLockedUntil) internal {\n    uint lockSeconds = _newLockedUntil > block.timestamp ? _newLockedUntil - block.timestamp : 0;\n    uint newBalance = (lockedBalanceOf[_account] * lockSeconds) / MAX_LOCK_PERIOD;\n    lockedUntil[msg.sender] = _newLockedUntil;\n    _setBalance(_account, newBalance);\n  }\n\n  function _setBalance(address _account, uint _amount) internal {\n    // Balance must be updated after claiming as it's used to calculate pending rewards\n    require(rewardSnapshot[msg.sender] == rewardPerToken, \"VeToken: claim first\");\n\n    if (balanceOf[_account] > _amount) {\n      _burn(_account, balanceOf[_account] - _amount);\n    } else if (balanceOf[_account] < _amount) {\n      _mint(_account, _amount - balanceOf[_account]);\n    }\n  }\n\n  function _mint(address _account, uint _amount) internal {\n    balanceOf[_account] += _amount;\n    totalSupply += _amount;\n    emit Transfer(address(0), _account, _amount);\n  }\n\n  function _burn(address _account, uint _amount) internal {\n    balanceOf[_account] -= _amount;\n    totalSupply -= _amount;\n    emit Transfer(_account, address(0), _amount);\n  }\n\n  function _pendingRewardPerToken() internal view returns(uint) {\n    if (totalSupply == 0) { return 0; }\n\n    uint blocksElapsed = block.number - lastAccrueBlock;\n    return blocksElapsed * rewardRate() * 1e18 / totalSupply;\n  }\n\n  function _checkReserves() internal view {\n    uint reserveBalance = IERC20(lockedToken).balanceOf(address(this));\n\n    uint blocksElapsed  = Math.min(distributionPeriod, block.number - lastIncomeBlock);\n    uint unvestedIncome = rewardRateStored * (distributionPeriod - blocksElapsed);\n\n    require(reserveBalance >= totalLocked + unvestedIncome, \"VeToken: reserve balance too low\");\n  }\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint);\n  function balanceOf(address account) external view returns(uint);\n  function transfer(address recipient, uint256 amount) external returns(bool);\n  function allowance(address owner, address spender) external view returns(uint);\n  function decimals() external view returns(uint8);\n  function approve(address spender, uint amount) external returns(bool);\n  function transferFrom(address sender, address recipient, uint amount) external returns(bool);\n}"
    },
    "SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\nimport \"IOwnable.sol\";\n\ncontract SafeOwnable is IOwnable {\n\n  uint public constant RENOUNCE_TIMEOUT = 1 hours;\n\n  address public override owner;\n  address public pendingOwner;\n  uint public renouncedAt;\n\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    require(isOwner(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function isOwner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function transferOwnership(address _newOwner) external override onlyOwner {\n    require(_newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferInitiated(owner, _newOwner);\n    pendingOwner = _newOwner;\n  }\n\n  function acceptOwnership() external override {\n    require(msg.sender == pendingOwner, \"Ownable: caller is not pending owner\");\n    emit OwnershipTransferConfirmed(msg.sender, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  function initiateRenounceOwnership() external onlyOwner {\n    require(renouncedAt == 0, \"Ownable: already initiated\");\n    renouncedAt = block.timestamp;\n  }\n\n  function acceptRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    require(block.timestamp - renouncedAt > RENOUNCE_TIMEOUT, \"Ownable: too early\");\n    owner = address(0);\n    pendingOwner = address(0);\n    renouncedAt = 0;\n  }\n\n  function cancelRenounceOwnership() external onlyOwner {\n    require(renouncedAt > 0, \"Ownable: not initiated\");\n    renouncedAt = 0;\n  }\n}"
    },
    "IOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ninterface IOwnable {\n  function owner() external view returns(address);\n  function transferOwnership(address _newOwner) external;\n  function acceptOwnership() external;\n}"
    },
    "Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nlibrary Math {\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow, so we distribute.\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n  }\n\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a / b + (a % b == 0 ? 0 : 1);\n  }\n}"
    },
    "ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.6;\n\ncontract ReentrancyGuard {\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor () {\n    _status = _NOT_ENTERED;\n  }\n\n  modifier nonReentrant() {\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n    _status = _ENTERED;\n    _;\n    _status = _NOT_ENTERED;\n  }\n}"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}