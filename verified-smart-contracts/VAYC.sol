{"SparkleMarket.sol":{"content":"//SPDX-License-Identifier: Unlicense\npragma solidity \u003e=0.8.0;\n\ninterface IERC721M {\n    function marketTransferFrom(address from, address to, uint256 tokenId) external;\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function getApproved(uint tokenId) external view returns (address approved);\n}\n\ncontract SparkleMarket {\n\n    IERC721M public nftContract;\n\n    uint256 constant NEVER_EXPIRE = 0;\n    address constant ANYBODY = address(0);\n    uint64 constant THE_PAST = 1;\n\n    struct Listing {\n        uint256 price;\n        address from;\n        address to;\n        uint64 expireTime;\n    }\n\n    mapping(uint256 =\u003e Listing) private listings;\n\n    event CreateListing(\n        uint256 indexed tokenID,\n        uint256 price,\n        address indexed from,\n        address indexed to,\n        uint64 expireTime\n    );\n\n    event CancelListing(address indexed from, uint256 indexed tokenID);\n\n    event Sale(\n        uint256 indexed tokenID,\n        uint256 price,\n        address indexed from,\n        address indexed to\n    );\n\n    constructor(address _nftContract) {\n        nftContract = IERC721M(_nftContract);\n    }\n\n    function _list(uint256 tokenId, uint256 price, address to, uint64 expireTime) internal {\n        _requireOwnerOrAllowed(tokenId, msg.sender);\n        require(expireTime \u003e block.timestamp || expireTime == NEVER_EXPIRE, \"Gotta let the listing have a valid expiration time!\");\n        listings[tokenId] = Listing({price: price, from: nftContract.ownerOf(tokenId), to: to, expireTime: expireTime });\n        emit CreateListing(tokenId, price, msg.sender, to, expireTime);\n    }\n\n    function listInWei(uint256 tokenId, uint256 priceInWeiNotEth, address to, uint64 expireTime) external {\n        _list(tokenId, priceInWeiNotEth, to, expireTime);\n    }\n\n    function listBatchInWei(\n        uint256[] calldata tokenIdList,\n        uint256[] calldata priceListInWeiNotEth,\n        address[] calldata toList,\n        uint64[] calldata expireTimeList) external {\n        for (uint i = 0; i \u003c tokenIdList.length; i++) {\n            _list(tokenIdList[i], priceListInWeiNotEth[i], toList[i], expireTimeList[i]);\n        }\n    }\n\n    function _requireOwnerOrAllowed(uint256 tokenId, address theAddress) internal view {\n        address tokenOwner = nftContract.ownerOf(tokenId);\n        require(tokenOwner == theAddress\n            || nftContract.isApprovedForAll(tokenOwner, theAddress)\n            || nftContract.getApproved(tokenId) == theAddress,\n            \"Address is not owner or approved\");\n    }\n\n    function cancelListing(uint256[] calldata tokenIdList) external {\n        for (uint i = 0; i \u003c tokenIdList.length; i++) {\n            uint256 tokenId = tokenIdList[i];\n            _requireOwnerOrAllowed(tokenId, msg.sender);\n            listings[tokenId].expireTime = THE_PAST;\n            emit CancelListing(msg.sender, tokenId);\n        }\n    }\n\n    function buy(uint256 tokenId) external payable {\n        Listing memory l = listings[tokenId];\n        require(l.from != address(0) \u0026\u0026\n                (l.price != 0 ||\n                l.to != address(0)),\n                \"Cannot buy an uninitialized listing\");\n        require(l.expireTime \u003e block.timestamp\n            || l.expireTime == NEVER_EXPIRE,\n            \"Listing must still be valid to be sold\");\n        require(l.price == msg.value, \"must send correct money to pay purchase price\");\n        require(l.from == nftContract.ownerOf(tokenId), \"Owner must still own for listing to be valid\");\n        if (l.to != ANYBODY)\n          require(l.to == msg.sender, \"if private sale, buyer must match target address the seller wants to sell to\");\n\n        listings[tokenId].expireTime = THE_PAST;\n        address payable from = payable(nftContract.ownerOf(tokenId));\n        nftContract.marketTransferFrom(from, msg.sender, tokenId);\n        from.transfer(msg.value);\n        emit Sale(tokenId, msg.value, from, msg.sender);\n    }\n\n    function buyBatch(uint256[] calldata tokenIdList) external payable {\n        uint sum = 0;\n        for(uint i = 0; i \u003c tokenIdList.length; i++) {\n            uint tokenId = tokenIdList[i];\n            Listing memory l = listings[tokenId];\n            require(l.expireTime != 0 ||\n                    l.price != 0 ||\n                    l.to != address(0),\n                    \"Cannot buy an uninitialized listing\");\n            require(l.expireTime \u003e block.timestamp\n                || l.expireTime == NEVER_EXPIRE,\n                \"Listing must still be valid to be sold\");\n            require(l.from == nftContract.ownerOf(tokenId), \"Owner must still own for listing to be valid\");\n            if (l.to != ANYBODY)\n              require(l.to == msg.sender, \"if private sale, buyer must match target address the seller wants to sell to\");\n            sum += l.price;\n        }\n\n        require(sum == msg.value, \"must send correct money to pay purchase price\");\n\n        for(uint i = 0; i \u003c tokenIdList.length; i++) {\n            uint tokenId = tokenIdList[i];\n            listings[tokenId].expireTime = THE_PAST;\n            address payable from = payable(nftContract.ownerOf(tokenId));\n            nftContract.marketTransferFrom(from, msg.sender, tokenId);\n            from.transfer(listings[tokenId].price);\n        }\n\n    }\n\n    function getListing(uint256 tokenId) external view returns (Listing memory) {\n        return listings[tokenId];\n    }\n\n    function isForSale(uint256 tokenId) external view returns (bool) {\n        if ( listings[tokenId].from != nftContract.ownerOf(tokenId) )\n            return false;\n        if ( listings[tokenId].expireTime \u003e block.timestamp)\n            return true;\n        bool listingInitialized = (listings[tokenId].price != 0 || listings[tokenId].to != ANYBODY);\n        if (listings[tokenId].expireTime == NEVER_EXPIRE \u0026\u0026 listingInitialized)\n            return true;\n        return false;\n    }\n\n}\n"},"VAYC.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.0;\n\n/// This file is forked from Solmate v6,\n/// We stand on the shoulders of giants\n/// Unnecessary functions have been deleted, mint, safeMint and burn\n/// Added our own mint functions, tweaked ownerOf to support our weirdness\n\nimport \"./SparkleMarket.sol\";\n\ninterface IERC721 {\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function setOwnerOf(uint256 id, address newOwner) external view returns (address owner);\n}\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\ncontract VAYC {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string private constant NOT_LIVE = \"Sale not live\";\n    string private constant INCORRECT_PRICE = \"Gotta pay right money\";\n    string private constant MINTED_OUT = \"Max supply reached\";\n    string public name;\n\n    string public symbol;\n\n    address private admin;\n    uint16 public totalSupply;\n    uint16 public counter = 0;\n    uint16 public constant  MAX_SUPPLY =  10000; // only first 10000 were minted\n\n    IERC721 private MAYC = IERC721(0x60E4d786628Fea6478F785A6d7e704777c86a7c6);\n    IERC721 private BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);\n    IERC721 private BAKC = IERC721(0xba30E5F9Bb24caa003E9f2f0497Ad287FDF95623);\n    //function setMAYC(address _mayc) public {MAYC = IERC721(_mayc);} //helper for unit testing\n    //IERC721 private MAYC = IERC721(0x6A8e25D0168B98e240d28a803e71ada93973F856);\n    //IERC721 private BAYC = IERC721(0x6A8e25D0168B98e240d28a803e71ada93973F856);\n    //IERC721 private BAKC = IERC721(address(0xdead));\n\n    SparkleMarket public market;\n    uint256 public constant COST_MAYC =   0.042069 ether;\n    uint256 public constant COST_PUBLIC = 0.069420 ether;\n    uint8 constant MAX_MINT = 10;\n\n   enum SaleStatus {\n       Paused,\n       Presale,\n       Whitelist,\n       Public\n    }\n    SaleStatus public saleMode;\n\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(uint256 =\u003e address) private preOf;\n\n    mapping(uint256 =\u003e address) private publicOf;\n\n    mapping(uint256 =\u003e address) public getApproved;\n\n    mapping(address =\u003e mapping(address =\u003e bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function ownerOf(uint256 id) public view returns (address) {\n        if (preOf[id] != address(0))\n            return preOf[id];\n        else\n            return publicOf[id];\n    }\n\n    function approve(address spender, uint256 id) external {\n        address owner = ownerOf(id);\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public {\n        require(from == ownerOf(id), \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender\u0027s balance is impossible because we check for\n        // ownership above and the recipient\u0027s balance can\u0027t realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        if (preOf[id] != address(0))\n            preOf[id] = to;\n        else\n            publicOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) external {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f;   // ERC165 Interface ID for ERC721Metadata\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"must be admin\");\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       VAYC SPECIFIC LOGIC\n    //////////////////////////////////////////////////////////////*/\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        admin = msg.sender;\n        market = new SparkleMarket(address(this));\n    }\n\n    function saleToPause() external onlyAdmin {\n        saleMode = SaleStatus.Paused;\n    }\n\n    function saleToPre() external onlyAdmin {\n        saleMode = SaleStatus.Presale;\n    }\n\n    function saleToWhitelist() external onlyAdmin {\n        saleMode = SaleStatus.Whitelist;\n    }\n\n    function saleToPublic() external onlyAdmin {\n        saleMode = SaleStatus.Public;\n    }\n\n    function withdraw() external onlyAdmin {\n        payable(admin).transfer(address(this).balance);\n    }\n\n    function mintPre(uint[] calldata tokenIds) external payable {\n        require(saleMode == SaleStatus.Presale, NOT_LIVE);\n        require(msg.value == COST_MAYC*tokenIds.length, INCORRECT_PRICE);\n        require(totalSupply + tokenIds.length \u003c MAX_SUPPLY, MINTED_OUT);\n        for (uint i = 0; i \u003c tokenIds.length; i++) {\n            require(msg.sender == MAYC.ownerOf(tokenIds[i]), \"Missing required token\");\n            require(tokenIds[i] \u003c MAX_SUPPLY, \"TokenId too high\");\n        }\n        for (uint i = 0; i \u003c tokenIds.length; i++) {\n            require(ownerOf(tokenIds[i]) == address(0), \"ALREADY_MINTED\");\n\n            // Counter overflow is incredibly unrealistic.\n            unchecked {\n                balanceOf[msg.sender]++;\n            }\n\n            preOf[tokenIds[i]] = msg.sender;\n            emit Transfer(address(0), msg.sender, tokenIds[i]);\n        }\n        unchecked{\n            totalSupply = totalSupply + (uint16(tokenIds.length));\n        }\n    }\n\n    function mintWL(uint16 num, uint tokenId) external payable {\n        require(saleMode == SaleStatus.Whitelist, NOT_LIVE);\n        bool baycFan =\n            (msg.sender == MAYC.ownerOf(tokenId)) ||\n            (msg.sender == BAYC.ownerOf(tokenId)) ||\n            (msg.sender == BAKC.ownerOf(tokenId));\n        require(baycFan, \"Not whitelisted\");\n        require(msg.value == COST_MAYC * num, INCORRECT_PRICE);\n        _mintY(num);\n    }\n\n    function mintPublic(uint16 num) external payable {\n        require(saleMode == SaleStatus.Public, NOT_LIVE);\n        require(msg.value == COST_PUBLIC * num, INCORRECT_PRICE);\n        _mintY(num);\n    }\n\n    function _mintY(uint16 num) internal {\n        require(num \u003c= MAX_MINT, \"Max 10 per TX\");\n        require(totalSupply + num \u003c MAX_SUPPLY, MINTED_OUT);\n        require(msg.sender.code.length == 0, \"Hack harder bot master\"); // bypassable, but raises level of effort\n        uint id = counter;\n        uint num_already_minted = 0;\n        while(num_already_minted \u003c num){\n            if (preOf[id] == address(0)) {\n                publicOf[id] = msg.sender;\n                emit Transfer(address(0), msg.sender, id);\n                num_already_minted += 1;\n            }\n            id += 1;\n        }\n        unchecked {\n            balanceOf[msg.sender] += num;\n            counter = uint16(id);\n            totalSupply = totalSupply + num;\n        }\n    }\n\n    // This function is here as a fallback in case we get undesirable gas consumption due to the\n    // structure of the preOf array. if it does, the owner can pause the contract, mint the offending\n    // token id and push public supply up to what it needs to be to get over O(n) SREAD operations in\n    // the MAYC Array.\n    // We may use it for promotions \u0026 giveaways.\n    // One can monitor the deployment address for suspicious activity if you do not trust the devs.\n    function mintAdmin(uint id, uint16 supplyOverwrite) external onlyAdmin {\n        unchecked {\n            publicOf[id] = msg.sender;\n            counter = supplyOverwrite;\n            balanceOf[msg.sender] += 1;\n            totalSupply += 1;\n        }\n        emit Transfer(address(0), msg.sender, id);\n    }\n\n    function uintToString(uint256 value) internal pure returns (string memory) {\n        // stolen from OpenZeppelin Strings library\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function tokenURI(uint256 id) external view returns (string memory) {\n        if(ownerOf(id) == address(0))\n            return \"\";\n        return string(abi.encodePacked(string(abi.encodePacked(\"ipfs://QmUupQShChuEV9r6qEKGLpd51qWj4zGtMzkpsCDTuUutJQ/\", uintToString(id))), \".json\")); // TODO CHANGE MEEEEEE\n    }\n\n    function marketTransferFrom(address from, address to, uint256 id) external {\n        require(msg.sender == address(market), \"INVALID_CALLER\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        if (preOf[id] != address(0))\n            preOf[id] = to;\n        else\n            publicOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n\n    }\n\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"}}