{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"GoldenTicket.sol":{"content":"pragma solidity \u003e=0.8.0 \u003c0.9.0;\n//SPDX-License-Identifier: MIT\n\nimport \"./IERC20.sol\";\nimport \"./Context.sol\";\nimport \"./Ownable.sol\";\n\n/**\n *\n * GoldenTicket Contract - NFTR\u0027s special name token\n * You need to spend (send to Registry Contract) one Golden Ticket\n * in addition to 365RNM to choose a name from the special names list\n * @dev Extends standard ERC20 contract\n */\ncontract GoldenTicket is Context, IERC20, Ownable {\n\n    // Constants\n    uint256 public constant MAX_SUPPLY = 1000;\n    // For bonding curve\n    uint256 constant a_times_sig = 1000;\n    uint256 constant SIG_DIGITS = 4;\n\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    address private _owner;\n\n    // NFTR Registry Contract address\n    address public nftrAddress;\n\n    // Funds reserved for burns\n    uint256 public reserve = 0;\n    // Accumulated mint fees (10% of every mint) that haven\u0027t been withdrawed\n    uint256 public accumulatedFees = 0;\n    // Number of tickets that have been used (sent, therefore locked in NFTR Contract) and whose \"unclaimable reserves\" / orphan funds have already been withdrawn\n    uint256 private numberTicketsFundsClaimedFor = 0;\n\n    // Events\n    /**\n     * @dev Emitted when a ticket is minted\n     */\n    event GoldenTicketsMinted(\n        address indexed to,\n        uint256 numTickets,\n        uint256 pricePaid,\n        uint256 nextMintPrice,\n        uint256 nextBurnPrice,\n        uint256 ticketSupply,\n        uint256 mintFee,\n        uint256 newReserve\n    );\n\n    /**\n     * @dev Emitted when a ticket is burned\n     */\n    event GoldenTicketsBurned(\n        address indexed to,\n        uint256 numTickets,\n        uint256 burnProceeds,\n        uint256 nextMintPrice,\n        uint256 nextBurnPrice,\n        uint256 ticketSupply,\n        uint256 newReserve\n    );\n\n    // Methods\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a value of 0 -- only whole tickets allowed. Sets the contract owner.\n     *\n     *\n     * All values except owner are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (address ownerin, string memory namein, string memory symbolin) {\n        name = namein;\n        symbol = symbolin;\n        _setupDecimals(0);\n        _owner = ownerin;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        decimals = decimals_;\n    }    \n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address ownerin, address spender) public view virtual override returns (uint256) {\n        return _allowances[ownerin][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Approval check is skipped if the caller of transferFrom is the NFTRegistry contract. For better UX.\n        if (_msgSender() != nftrAddress) {\n            require(_allowances[sender][_msgSender()] \u003e= amount,\"ERC20: transfer amount exceeds allowance\");\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        require(_allowances[_msgSender()][spender] \u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        require(_balances[sender] \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /**\n     * @dev Callable only once. It is manually set right after deployment and verified.\n     */\n    function setNFTRegistryAddress(address _nftrAddress) public onlyOwner {\n        require(nftrAddress == address(0), \"Already set\");\n        \n        nftrAddress = _nftrAddress;\n    }\n\n    /**\n     * @dev Get amount of ETH in reserve\n     */\n    function getReserve() public view returns (uint256) {\n        return reserve;\n    }    \n\n    /**\n     * @dev Get accumulated fees\n     */\n    function getAccumulatedFees() public view returns (uint256) {\n        return accumulatedFees;\n    }   \n\n    /**\n     * @dev Get number of used tickets (i.e. tickets in NFTR contract balance)\n     */\n    function numberUsedTickets() public view returns (uint256 nftrTicketBalance) {\n        if(nftrAddress == address(0)) {\n            nftrTicketBalance = 0;\n        }\n        else {\n            nftrTicketBalance = balanceOf(nftrAddress);\n        }\n    }\n\n    /**\n     * @dev Get accumulated orphan ticket extractable funds\n     */\n    function getOrphanedTicketFunds() public view returns (uint256) {\n        uint256 unclaimedOrphanFunds = 0;\n        if (nftrAddress != address(0)) { // NFTR contract has already been set and could have GTKs in its balance\n            uint256 nftrTicketBalance = balanceOf(nftrAddress);\n            uint256 orphanFundsWithdrawn = getOrphanFundsForUsedTicketNumber(numberTicketsFundsClaimedFor);\n            uint256 totalOrphanFunds = getOrphanFundsForUsedTicketNumber(nftrTicketBalance);\n            unclaimedOrphanFunds = totalOrphanFunds - orphanFundsWithdrawn;\n        }\n        return unclaimedOrphanFunds;\n    }\n\n    /**\n     * @dev Returns mint price of the mintNumber golden ticket in wei\n     *\n     */\n    function getSingleMintPrice(uint256 mintNumber) public pure returns (uint256 price) {\n        require(mintNumber \u003c= MAX_SUPPLY, \"Maximum supply exceeded\");\n        require(mintNumber \u003e 0, \"Minting a supply of 0 tickets isn\u0027t valid\");\n\n        uint256 dec = 10 ** SIG_DIGITS;\n        price = a_times_sig + (mintNumber * (mintNumber));\n\n        price = price * (1 ether) / (dec);\n    }\n\n    /**\n     * @dev Returns mint price of the next golden ticket in wei\n     */\n    function currentMintPrice(uint256 quantity) public view returns (uint256 price) {\n        uint256 dec = 10 ** SIG_DIGITS;\n        price = 0;\n        uint256 mintNumber;\n        for (uint i = 0; i \u003c quantity; i++) {\n            mintNumber = totalSupply() + (i + 1);\n            price += a_times_sig + (mintNumber * (mintNumber));\n        }\n        price = price * (1 ether) / (dec);\n    }\n \n    /**\n     * @dev Function to get funds received when burned\n     * @param supply the golden ticket supply before buring. Ex. if there are 3 existing tickets, to get the funds\n     * received on burn, supply should be 3\n     */\n    function getSingleBurnPrice(uint256 supply) public pure returns (uint256 price) {\n        if (supply == 0) return 0;\n        uint256 mintPrice = getSingleMintPrice(supply);\n        price = mintPrice * (90) / (100);  // 90 % of mint price of last minted ticket (i.e. current supply)\n    }    \n\n    /**\n     * @dev Function to get amount of funds received currently when ticket is burned\n     */\n    function currentBurnPrice(uint256 quantity) public view returns (uint256 price) {\n        if (totalSupply() == 0) return 0;\n        if (quantity \u003e totalSupply()) return 0;\n        uint256 mintPrice;\n        for (uint i = 0; i \u003c quantity; i++) {\n            mintPrice += getSingleMintPrice(totalSupply() - i);\n        }\n        price = mintPrice * (90) / (100);  // 90 % of mint price of last minted ticket (i.e. current supply)\n    }  \n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply + (amount);\n        _balances[account] = _balances[account] + (amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        require(_balances[account] \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = _balances[account] - amount;\n        _totalSupply = _totalSupply - (amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address ownerin, address spender, uint256 amount) internal virtual {\n        require(ownerin != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[ownerin][spender] = amount;\n        emit Approval(ownerin, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n\n        /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\u0027s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``\u0027s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n   /**\n     * @dev Mints *quantity* Golden Tickets to the address of the sender\n     * @param quantity The number of Golden Tickets to mint\n     */\n    function mintTickets(uint256 quantity)\n        public\n        payable\n        returns (uint256)\n    {\n        require(quantity \u003e 0, \"Can\u0027t mint 0 Golden Tickets\");\n        require(_totalSupply + quantity \u003c= MAX_SUPPLY, \"That quantity of tickets takes supply over max supply\");\n        uint256 oldSupply = _totalSupply;\n        // Get price to mint *quantity* tickets\n        uint256 mintPrice = 0;\n        for (uint i = 0; i \u003c quantity; i++) {\n            mintPrice += getSingleMintPrice(oldSupply + (i + 1));\n        }\n        \n        require(msg.value \u003e= mintPrice, \"Insufficient funds\");\n\n        uint256 newSupply = _totalSupply + (quantity);\n\n        // Update reserve - reserveCut == Price to burn next ticket\n        uint256 reserveCut = 0;\n        for (uint i = 0; i \u003c quantity; i++) {\n            reserveCut += getSingleBurnPrice(newSupply - i);\n        }\n        reserve = reserve + (reserveCut);\n        accumulatedFees = accumulatedFees + (mintPrice) - (reserveCut);\n\n        // Mint token\n        _mint(msg.sender,  quantity);\n\n        // If buyer sent extra ETH as padding in case another purchase was made they are refunded\n        _refundSender(mintPrice, msg.value);\n\n        emit GoldenTicketsMinted(msg.sender, quantity, mintPrice, getSingleMintPrice(newSupply + (1)), getSingleBurnPrice(newSupply), newSupply, mintPrice - (reserveCut), reserve);\n        \n        return newSupply;\n    }    \n\n    /**\n     * @dev If sender sends more Ether than necessary when minting, refunds the extra funds\n     *\n     */\n    function _refundSender(uint256 mintPrice, uint256 msgValue) internal {\n        if (msgValue - (mintPrice) \u003e 0) {\n            (bool success, ) =\n                msg.sender.call{value: msgValue - (mintPrice)}(\"\");\n            require(success, \"Refund failed\");\n        }\n    }\n\n        /**\n     * @dev Function to burn a ticket\n     * @param minimumSupply The minimum token supply for burn to succeed, this is a way to set slippage. \n     * Set to 1 to allow burn to go through no matter what the price is.\n     * @param quantity The number of Golden Tickets to burn\n     */\n    function burnTickets(uint256 minimumSupply, uint256 quantity) public returns (uint256) {\n        uint256 oldSupply = _totalSupply;\n        require(oldSupply \u003e= minimumSupply, \u0027Min supply not met\u0027);\n        require(quantity \u003e 0, \"Can\u0027t burn 0 Golden Tickets\");\n        require(quantity \u003c= _totalSupply, \"Can\u0027t burn more tickets than total supply\");\n\n        uint256 burnPrice = 0;\n        for (uint i = 0; i \u003c quantity; i++) {\n            burnPrice += getSingleBurnPrice(oldSupply - i);\n        }\n        uint256 newSupply = _totalSupply - (quantity);\n\n        // Update reserve\n        reserve = reserve - (burnPrice);\n\n        _burn(msg.sender, quantity);\n\n        // Disburse funds\n        (bool success, ) = msg.sender.call{value: burnPrice}(\"\");\n        require(success, \"Burn payment failed\");\n\n        emit GoldenTicketsBurned(msg.sender, quantity, burnPrice, getSingleMintPrice(oldSupply - quantity + 1), getSingleBurnPrice(newSupply), newSupply, reserve);\n\n        return newSupply;\n    }     \n\n    /**\n     * @dev Function that calculates previously reserved exit (burn) liquidity \n     * that will be claimed by burning since they have already been used to \n     * name (i.e. they have been transferred to the NFTR Contract)\n     */\n    function getOrphanFundsForUsedTicketNumber(uint256 ticketNumber) internal pure returns (uint256 _orphanFunds) { \n        // Summing ticket mint prices from k = 1 to n, then multiplying by 9/10 (90%). Reduces to:\n        _orphanFunds = 9 * ticketNumber * 10 ** 16 + ticketNumber * (ticketNumber + 1) * (2 * ticketNumber + 1) * 9 / 6 * 10 ** 13;\n    } \n\n     /**\n     * @dev Withdraw treasury ETH\n     */\n    function withdraw() public onlyOwner {\n        uint256 unclaimedOrphanFunds = 0;\n        if (nftrAddress != address(0)) { // NFTR contract has already been set and could have GTs in its balance\n            uint256 nftrTicketBalance = balanceOf(nftrAddress);\n            uint256 orphanFundsWithdrawn = getOrphanFundsForUsedTicketNumber(numberTicketsFundsClaimedFor);\n            uint256 totalOrphanFunds = getOrphanFundsForUsedTicketNumber(nftrTicketBalance);\n            unclaimedOrphanFunds = totalOrphanFunds - orphanFundsWithdrawn;\n            numberTicketsFundsClaimedFor = nftrTicketBalance;\n        }\n        uint256 withdrawableFunds = accumulatedFees + (unclaimedOrphanFunds);\n        accumulatedFees = 0;\n        (bool success, ) = msg.sender.call{value: withdrawableFunds}(\"\");\n        require(success, \"Withdraw failed\");\n    } \n\n}"},"IERC20.sol":{"content":"pragma solidity \u003e=0.8.0 \u003c0.9.0;\n//SPDX-License-Identifier: MIT\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}}