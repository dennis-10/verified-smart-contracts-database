{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": false
      },
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/persistent/address-list-registry/AddressListRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../dispatcher/IDispatcher.sol\";\n\n/// @title AddressListRegistry Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract for creating and updating lists of addresses\ncontract AddressListRegistry {\n    enum UpdateType {None, AddOnly, RemoveOnly, AddAndRemove}\n\n    event ItemAddedToList(uint256 indexed id, address item);\n\n    event ItemRemovedFromList(uint256 indexed id, address item);\n\n    event ListAttested(uint256 indexed id, string description);\n\n    event ListCreated(\n        address indexed creator,\n        address indexed owner,\n        uint256 id,\n        UpdateType updateType\n    );\n\n    event ListOwnerSet(uint256 indexed id, address indexed nextOwner);\n\n    event ListUpdateTypeSet(\n        uint256 indexed id,\n        UpdateType prevUpdateType,\n        UpdateType indexed nextUpdateType\n    );\n\n    struct ListInfo {\n        address owner;\n        UpdateType updateType;\n        mapping(address => bool) itemToIsInList;\n    }\n\n    address private immutable DISPATCHER;\n\n    ListInfo[] private lists;\n\n    modifier onlyListOwner(uint256 _id) {\n        require(__isListOwner(msg.sender, _id), \"Only callable by list owner\");\n        _;\n    }\n\n    constructor(address _dispatcher) public {\n        DISPATCHER = _dispatcher;\n\n        // Create the first list as completely empty and immutable, to protect the default `id`\n        lists.push(ListInfo({owner: address(0), updateType: UpdateType.None}));\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Adds items to a given list\n    /// @param _id The id of the list\n    /// @param _items The items to add to the list\n    function addToList(uint256 _id, address[] calldata _items) external onlyListOwner(_id) {\n        UpdateType updateType = getListUpdateType(_id);\n        require(\n            updateType == UpdateType.AddOnly || updateType == UpdateType.AddAndRemove,\n            \"addToList: Cannot add to list\"\n        );\n\n        __addToList(_id, _items);\n    }\n\n    /// @notice Attests active ownership for lists and (optionally) a description of each list's content\n    /// @param _ids The ids of the lists\n    /// @param _descriptions The descriptions of the lists' content\n    /// @dev Since UserA can create a list on behalf of UserB, this function provides a mechanism\n    /// for UserB to attest to their management of the items therein. It will not be visible\n    /// on-chain, but will be available in event logs.\n    function attestLists(uint256[] calldata _ids, string[] calldata _descriptions) external {\n        require(_ids.length == _descriptions.length, \"attestLists: Unequal arrays\");\n\n        for (uint256 i; i < _ids.length; i++) {\n            require(\n                __isListOwner(msg.sender, _ids[i]),\n                \"attestLists: Only callable by list owner\"\n            );\n\n            emit ListAttested(_ids[i], _descriptions[i]);\n        }\n    }\n\n    /// @notice Creates a new list\n    /// @param _owner The owner of the list\n    /// @param _updateType The UpdateType for the list\n    /// @param _initialItems The initial items to add to the list\n    /// @return id_ The id of the newly-created list\n    /// @dev Specify the DISPATCHER as the _owner to make the Enzyme Council the owner\n    function createList(\n        address _owner,\n        UpdateType _updateType,\n        address[] calldata _initialItems\n    ) external returns (uint256 id_) {\n        id_ = getListCount();\n\n        lists.push(ListInfo({owner: _owner, updateType: _updateType}));\n\n        emit ListCreated(msg.sender, _owner, id_, _updateType);\n\n        __addToList(id_, _initialItems);\n\n        return id_;\n    }\n\n    /// @notice Removes items from a given list\n    /// @param _id The id of the list\n    /// @param _items The items to remove from the list\n    function removeFromList(uint256 _id, address[] calldata _items) external onlyListOwner(_id) {\n        UpdateType updateType = getListUpdateType(_id);\n        require(\n            updateType == UpdateType.RemoveOnly || updateType == UpdateType.AddAndRemove,\n            \"removeFromList: Cannot remove from list\"\n        );\n\n        // Silently ignores items that are not in the list\n        for (uint256 i; i < _items.length; i++) {\n            if (isInList(_id, _items[i])) {\n                lists[_id].itemToIsInList[_items[i]] = false;\n\n                emit ItemRemovedFromList(_id, _items[i]);\n            }\n        }\n    }\n\n    /// @notice Sets the owner for a given list\n    /// @param _id The id of the list\n    /// @param _nextOwner The owner to set\n    function setListOwner(uint256 _id, address _nextOwner) external onlyListOwner(_id) {\n        lists[_id].owner = _nextOwner;\n\n        emit ListOwnerSet(_id, _nextOwner);\n    }\n\n    /// @notice Sets the UpdateType for a given list\n    /// @param _id The id of the list\n    /// @param _nextUpdateType The UpdateType to set\n    /// @dev Can only change to a less mutable option (e.g., both add and remove => add only)\n    function setListUpdateType(uint256 _id, UpdateType _nextUpdateType)\n        external\n        onlyListOwner(_id)\n    {\n        UpdateType prevUpdateType = getListUpdateType(_id);\n        require(\n            _nextUpdateType == UpdateType.None || prevUpdateType == UpdateType.AddAndRemove,\n            \"setListUpdateType: _nextUpdateType not allowed\"\n        );\n\n        lists[_id].updateType = _nextUpdateType;\n\n        emit ListUpdateTypeSet(_id, prevUpdateType, _nextUpdateType);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to add items to a list\n    function __addToList(uint256 _id, address[] memory _items) private {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInList(_id, _items[i])) {\n                lists[_id].itemToIsInList[_items[i]] = true;\n\n                emit ItemAddedToList(_id, _items[i]);\n            }\n        }\n    }\n\n    /// @dev Helper to check if an account is the owner of a given list\n    function __isListOwner(address _who, uint256 _id) private view returns (bool isListOwner_) {\n        address owner = getListOwner(_id);\n        return\n            _who == owner ||\n            (owner == getDispatcher() && _who == IDispatcher(getDispatcher()).getOwner());\n    }\n\n    /////////////////\n    // LIST SEARCH //\n    /////////////////\n\n    // These functions are concerned with exiting quickly and do not consider empty params.\n    // Developers should sanitize empty params as necessary for their own use cases.\n\n    // EXTERNAL FUNCTIONS\n\n    // Multiple items, single list\n\n    /// @notice Checks if multiple items are all in a given list\n    /// @param _id The list id\n    /// @param _items The items to check\n    /// @return areAllInList_ True if all items are in the list\n    function areAllInList(uint256 _id, address[] memory _items)\n        external\n        view\n        returns (bool areAllInList_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInList(_id, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all absent from a given list\n    /// @param _id The list id\n    /// @param _items The items to check\n    /// @return areAllNotInList_ True if no items are in the list\n    function areAllNotInList(uint256 _id, address[] memory _items)\n        external\n        view\n        returns (bool areAllNotInList_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (isInList(_id, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Multiple items, multiple lists\n\n    /// @notice Checks if multiple items are all in all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllInAllLists_ True if all items are in all of the lists\n    function areAllInAllLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllInAllLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInAllLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all in one of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllInSomeOfLists_ True if all items are in one of the lists\n    function areAllInSomeOfLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllInSomeOfLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInSomeOfLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all absent from all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllNotInAnyOfLists_ True if all items are absent from all lists\n    function areAllNotInAnyOfLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllNotInAnyOfLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (isInSomeOfLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    // Single item, multiple lists\n\n    /// @notice Checks if an item is in all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _item The item to check\n    /// @return isInAllLists_ True if item is in all of the lists\n    function isInAllLists(uint256[] memory _ids, address _item)\n        public\n        view\n        returns (bool isInAllLists_)\n    {\n        for (uint256 i; i < _ids.length; i++) {\n            if (!isInList(_ids[i], _item)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if an item is in at least one of a given set of lists\n    /// @param _ids The list ids\n    /// @param _item The item to check\n    /// @return isInSomeOfLists_ True if item is in one of the lists\n    function isInSomeOfLists(uint256[] memory _ids, address _item)\n        public\n        view\n        returns (bool isInSomeOfLists_)\n    {\n        for (uint256 i; i < _ids.length; i++) {\n            if (isInList(_ids[i], _item)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the total count of lists\n    /// @return count_ The total count\n    function getListCount() public view returns (uint256 count_) {\n        return lists.length;\n    }\n\n    /// @notice Gets the owner of a given list\n    /// @param _id The list id\n    /// @return owner_ The owner\n    function getListOwner(uint256 _id) public view returns (address owner_) {\n        return lists[_id].owner;\n    }\n\n    /// @notice Gets the UpdateType of a given list\n    /// @param _id The list id\n    /// @return updateType_ The UpdateType\n    function getListUpdateType(uint256 _id) public view returns (UpdateType updateType_) {\n        return lists[_id].updateType;\n    }\n\n    /// @notice Checks if an item is in a given list\n    /// @param _id The list id\n    /// @param _item The item to check\n    /// @return isInList_ True if the item is in the list\n    function isInList(uint256 _id, address _item) public view returns (bool isInList_) {\n        return lists[_id].itemToIsInList[_item];\n    }\n}\n"
    },
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDispatcher Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IDispatcher {\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function claimOwnership() external;\n\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external returns (address vaultProxy_);\n\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\n\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (address fundDeployer_);\n\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        );\n\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\n\n    function getNominatedOwner() external view returns (address nominatedOwner_);\n\n    function getOwner() external view returns (address owner_);\n\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\n\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (uint256 secondsRemaining_);\n\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasExecutableRequest_);\n\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasMigrationRequest_);\n\n    function removeNominatedOwner() external;\n\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\n\n    function setMigrationTimelock(uint256 _nextTimelock) external;\n\n    function setNominatedOwner(address _nextNominatedOwner) external;\n\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\n\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external;\n}\n"
    }
  }
}}